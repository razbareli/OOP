unixraz


=============================
=      File description     =
=============================
filesprocessing package:
	filesexceptions package:
        		TypeOneExceptions -  class for exeptions of type 1
        		TypeTwoExceptions - class for exeptions of type 2
	filesfilters package:
		FilterInterface - an interface for all filters to implement. includes one
 			boolean method, that checks a different
 			condition in every filter
		SingleDoubleFilter - abstract class for filters using single
 			number representing file size, to filter the files by
		StringFilter -  abstract class for a filter that receives a string
 			and filters the file based on that string
		YesNoFilter - abstract class for filters that filter files based on
 			if they have or does not have a certain attribute
		Allfilter -  all files get true with this filter
		BetweenFilter - filters files that have a size between two values
		ContainsFilter -  filters files that contains a certain string
        		ExecutableFilter - filters a file based on if it is executable or not
		FileFilter - filters files with the same name as the given one
		GreaterThanFilter - filter files greater than a certain size
		HiddenFilter - filters a file based on if it is hidden or not
		PrefixFilter - filters files that starts a certain string
		SmallerThanFilter - filter files greater than a certain size
		SuffixFilter - filters files that starts a certain string
		WrieableFilter - filters a file based on if it is writeable or not
	filesorders package:
		OrderSort - abstract class for orders includes one sort method
		AbsOrder - orders the file based on absolute path name
		SizeOrder - orders the files based on their size
		TypeOrder - orders the files based on their type of file
	filessections package:
		Section - represents a section within the FILTER/ORDER file
		SectionsFactory - creates multiple sections according to the .flt file given
	FilesUtilities - includes utility functions for the program
	DirectoryProcessor - has a main function that runs the program


=============================
=          Design           =
=============================
In this exercise we have been asked to combine design principles that we have learned in the class.
I have focused on modularity, factory and singleton.
First, I have divided the main package to 4 sub-packages, each one contains:
exceptions, filters, orders, and sections.
The code is more organized and understandable that way.
Each package contains classes, and each class is taking care of a small fraction of the program.

For example, each filter has it's own class and is independent of the other, so if we will add a new
filter in the future, that won't affect all the other filters.
Since each filter is yielding a boolean expression, I've decided to use an interface that is having one boolean
filter method that is implemented differently by all other filters.

In the order package - I've used an abstract class instead of an interface because the sort method
is exactly the same in all orders, just the comparison is different, so there was no point in making an 
Interface and implement the same function 3 times.

The sections package contains a sectionFactory class, which is responsible to generate all sections implied by the .flt
file we are reading.
This approach satisfies the factory design pattern as we have learned in the class:
This class is only one that creates the actual sections which are the main of the program.

Also, I have used a Singleton of this class to make sure there is only one instance of it, as we
have learned to do:
In the main() method of the program, the singe instance of the factory is generated by the instance() method.
Because the constructor is private, there is no way of generating more instances.
Also the Single choice principle can be seen here, in the fact that all filter/order options are only known to the
SectionsFactory class: they are all static and final, and if we'll want to add new filter name we could do it in
the factory and don't worry about the rest of the program (of course we'll have to implement a
new filter class for it as well).

Finally, the main method in the DirectoryProcessor runs the program.
It only interacts with the classes Sections Package, which shows that the code is broken into small 
modules, has good hierarchy and can be easily maintained.


=============================
=  Implementation issues   =
=============================
NA

=============================
=    Answers to questions   =
=============================
Exceptions hierarchy:
I have chosen the following hierarchy:
TypeOneExeptions are thrown only be the filters/orders methods,
And gets caught and handled only in the SectionFactory class.
TypeTwoExeptions are thrown only be the sectionGenerator() method in the factory class,
and is handled in the main() method in DirectoryProcessor.
I have chosen this hierarchy because this allows me to handle where the program has warnings,
(according to TypeOneExceptions) so I can print the line the warning appears in.
On the other hand, because the main() method is running the program, it is reasonable
that it will handle the TypeTwoExeptions, and will terminate the program in case it catches such
exception.

How I sorted:
I have chosen to work with java ArrayList<> to maintain and sort the files in the directory,
because this data structure has order, so it is possible to sort it. in addition, I
can add and remove elements if needed before the sorting (as I do with the filters).
I have chosen to sort using quick sort with a compare function:
each order class overrides the abstract compare function, according to its type of sorting,
so that makes the sorting function common in all kinds of sorting, that way there is no need to
change it if we'll add a new kind of sorting. We'll simply just implement a new compare function.
This makes the code easy to extend and maintain.



